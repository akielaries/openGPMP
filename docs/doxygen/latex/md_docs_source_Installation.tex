Requirements are loose and mostly tied to what open\+MTPK was tested and used on. The current installation does not allow for the building of the packages language bindings, limiting use to the core c++ lib. See below on how to build the bindings from source if interested.\hypertarget{md_docs_source_Installation_autotoc_md6}{}\doxysection{Requirements}\label{md_docs_source_Installation_autotoc_md6}

\begin{DoxyItemize}
\item Linux/\+OSX
\item CMake
\item g++
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\# clone repo}
\DoxyCodeLine{\$ git clone git@github.com:akielaries/openMTPK.git}
\DoxyCodeLine{\$ cd oepnMTPK}
\DoxyCodeLine{\# create build dir}
\DoxyCodeLine{\$ mkdir build \&\& cd build}
\DoxyCodeLine{\# create necessary objects and static library}
\DoxyCodeLine{\$ cmake ..}
\DoxyCodeLine{\$ make}
\DoxyCodeLine{\# install necessary headers and library in correct directories}
\DoxyCodeLine{\$ sudo make install}

\end{DoxyCode}
 \begin{quote}
{\bfseries{Note}} This process asumes your STDLIB path is /usr/local/lib, where most 3rd-\/party libs are located if not, run the following\+: \end{quote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\$ LD\_LIBRARY\_PATH=/usr/local/lib}

\end{DoxyCode}


To test the installation build some of the example drivers in the projects \href{https://github.com/akielaries/openMTPK/tree/main/samples}{\texttt{ samples}} directory. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\# compile yourself}
\DoxyCodeLine{\$ cd samples}
\DoxyCodeLine{\$ g++ cipher.cpp -\/lopenMTPK -\/o cipher}
\DoxyCodeLine{\$ g++ arith.cpp -\/lopenMTPK -\/o arith}
\DoxyCodeLine{\# script to test all modules and their drivers}
\DoxyCodeLine{\# using the projects root makefile}
\DoxyCodeLine{\$ make arith}
\DoxyCodeLine{\$ make num-\/theory}
\DoxyCodeLine{...}

\end{DoxyCode}
 \hypertarget{md_docs_source_Installation_autotoc_md7}{}\doxysection{Dependencies}\label{md_docs_source_Installation_autotoc_md7}
\begin{quote}
{\bfseries{Warning}} At the moment these dependencies do not apply to the current release. \end{quote}
The goal of open\+MTPK is to have as little dependencies as possible without re-\/inventing the wheel too much while performing speedy computations. Other than C and C++ standard libraries the 3rd-\/party dependencies that are used are deemed necessary for many of the packages functionalities. open\+MTPK makes use of a few open source cross-\/platform compatible packages and libraries in the cases of threading for performance, graphics libraries, and packages for testing and fuzzing.


\begin{DoxyItemize}
\item open\+MP\+: Open Multi-\/\+Processing is useful for simple threading when needed. For loops that don\textquotesingle{}t make complex calls can be encosed in a {\ttfamily \#pragma omp parallel for \{\}} declaration.
\item open\+CL\+: Open Computing Language is another useful threading API that allows for more customized parallelization techniques.
\item open\+GL\+: Open Graphics Library used for hardware-\/accelerated rendering. API makes use of interaction with a machines Graphics Processing Unit (GPU) allowing for quick rendering of modules that make use.
\item lib\+Xbgi\+: Borland Graphics Interface reiteration. Provides a useful graphics API to get started with visualizing mathematical algorithms.
\end{DoxyItemize}\hypertarget{md_docs_source_Installation_autotoc_md8}{}\doxysection{Tools}\label{md_docs_source_Installation_autotoc_md8}

\begin{DoxyItemize}
\item Gtest\+: Used for unit testing. Within the projects development Makefile, there are option to run the tests for the modules in this package. This is done by compiling a driver file that runs the methods referenced in each module, the source module file itself, and then the gtest based test driver file for said module. Some modules are harder to test than others but for the most part simply checking the expected output against the computed output does all the checking that is needed.
\item AFL and AFL++\+: AFL is a fuzzing tool built by Google but now deprecated. AFL++ is an open source community effort forked from AFL offering the same functionalities but much better. Advertised as better mutations, more speed, and better instrumentation. Fuzzing comes in handy for generating random inputs for your program and analyzing the outputs Analyzing crashes, unique or not, proves valuable for implementing strong and secure code.
\end{DoxyItemize}

The code below is an example on how testing on the arithmetic module was done. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\{c++\}}
\DoxyCodeLine{   \#include <openMTPK/arithmetic/arith.hpp>}
\DoxyCodeLine{   \#include <gtest/gtest.h>}
\DoxyCodeLine{   namespace \{}
\DoxyCodeLine{       arith ar;}
\DoxyCodeLine{       // test case, test name}
\DoxyCodeLine{       TEST(arith\_test, add\_positive) \{}
\DoxyCodeLine{           EXPECT\_EQ(46094, ar.rm\_add(93, 106, 3551, 42344));}
\DoxyCodeLine{           EXPECT\_EQ(6.85, ar.rm\_add(1.25, 1.85, 2.75, 1));}
\DoxyCodeLine{       \}}
\DoxyCodeLine{       // multiplication (product) testing}
\DoxyCodeLine{       TEST(arith\_test, mult\_positive) \{}
\DoxyCodeLine{           EXPECT\_EQ(240, ar.rm\_mult(10, 8, 3));}
\DoxyCodeLine{           EXPECT\_EQ(6.359375, ar.rm\_mult(1.25, 1.85, 2.75, 1));}
\DoxyCodeLine{       \}}
\DoxyCodeLine{       // subtraction}
\DoxyCodeLine{       TEST(arith\_test, sub\_positive) \{}
\DoxyCodeLine{           EXPECT\_EQ(5, ar.rm\_sub(10, 8, 3));}
\DoxyCodeLine{           EXPECT\_EQ(1, ar.rm\_sub(1.25, 1.85, 2.75));}
\DoxyCodeLine{       \}}
\DoxyCodeLine{  \}}

\end{DoxyCode}
 